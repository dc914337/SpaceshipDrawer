using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using SlimDX; using SlimDX.D3DCompiler; using SlimDX.DXGI; using SlimDX.Direct3D11; using Debug = System.Diagnostics.Debug; using System.Collections.Generic; using System.Diagnostics;  namespace SpaceshipDrawer {     using System.Windows.Forms;     using Core;     using Core.Vertex;      using SlimDX;      using Buffer = SlimDX.Direct3D11.Buffer;     using Effect = SlimDX.Direct3D11.Effect;     using System.Drawing;     using System.IO;
    using Model;
    using static Core.GeometryGenerator;
    using polygonizer;
    class TestApp : D3DApp     {         private Buffer _vb;         private Buffer _ib;          private Effect _fx;         private EffectTechnique _tech;         private EffectMatrixVariable _fxWVP;          private InputLayout _inputLayout;          private RasterizerState _wireframeRS;         private Matrix[] _sphereWorld = new Matrix[10];         private Matrix[] _cylWorld = new Matrix[10];         private Matrix _boxWorld;         private Matrix _gridWorld;         private Matrix _centerSphere;          private Matrix _view;         private Matrix _proj;          private int _spaceShipVertexOffset;         private int _spaceShipIndexOffset;         private int _spaceShipIndexCount;          private float _theta;         private float _phi;         private float _radius;         private Point _lastMousePos;           Hull _spaceshipToShow;            private bool _disposed;         public TestApp(IntPtr hInstance, Hull spaceship)         : base(hInstance)     {             _spaceshipToShow = spaceship;             _vb = null;             _ib = null;             _fx = null;             _tech = null;             _fxWVP = null;             _inputLayout = null;             _wireframeRS = null;             _theta = 1.5f * MathF.PI;             _phi = 0.1f * MathF.PI;             _radius = 15.0f;              MainWindowCaption = "Shapes Demo";             _lastMousePos = new Point(0, 0);              _gridWorld = Matrix.Identity;             _view = Matrix.Identity;             _proj = Matrix.Identity;              _boxWorld = Matrix.Scaling(2.0f, 1.0f, 2.0f) * Matrix.Translation(0, 0.5f, 0);             _centerSphere = Matrix.Scaling(2.0f, 2.0f, 2.0f) * Matrix.Translation(0, 2, 0);              for (int i = 0; i < 5; ++i)             {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f, 1.5f, -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f, 1.5f, -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f, 3.5f, -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f, 3.5f, -10.0f + i * 5.0f);             }          }         protected override void Dispose(bool disposing)         {             if (!_disposed)             {                 if (disposing)                 {                     Util.ReleaseCom(ref _vb);                     Util.ReleaseCom(ref _ib);                     Util.ReleaseCom(ref _fx);                     Util.ReleaseCom(ref _inputLayout);                     Util.ReleaseCom(ref _wireframeRS);                 }                 _disposed = true;             }             base.Dispose(disposing);         }         public override bool Init()         {             if (!base.Init())             {                 return false;             }             BuildGeometryBuffers();             BuildFX();             BuildVertexLayout();              var wireFrameDesc = new RasterizerStateDescription             {                 FillMode = FillMode.Wireframe,                 CullMode = CullMode.Back,                 IsFrontCounterclockwise = false,                 IsDepthClipEnabled = true             };              _wireframeRS = RasterizerState.FromDescription(Device, wireFrameDesc);             return true;         }         public override void OnResize()         {             base.OnResize();              _proj = Matrix.PerspectiveFovLH(0.25f * MathF.PI, AspectRatio, 1.0f, 1000.0f);         }         public override void UpdateScene(float dt)         {             base.UpdateScene(dt);              // Get camera position from polar coords             var x = _radius * MathF.Sin(_phi) * MathF.Cos(_theta);             var z = _radius * MathF.Sin(_phi) * MathF.Sin(_theta);             var y = _radius * MathF.Cos(_phi);              // Build the view matrix             var pos = new Vector3(x, y, z);             var target = new Vector3(0);             var up = new Vector3(0, 1, 0);             _view = Matrix.LookAtLH(pos, target, up);         }         public override void DrawScene()         {             base.DrawScene();             ImmediateContext.ClearRenderTargetView(RenderTargetView, Color.Wheat);             ImmediateContext.ClearDepthStencilView(DepthStencilView, DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil, 1.0f, 0);              ImmediateContext.InputAssembler.InputLayout = _inputLayout;             ImmediateContext.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;              ImmediateContext.Rasterizer.State = _wireframeRS;              ImmediateContext.InputAssembler.SetVertexBuffers(0, new VertexBufferBinding(_vb, VertexPC.Stride, 0));             ImmediateContext.InputAssembler.SetIndexBuffer(_ib, Format.R32_UInt, 0);              var viewProj = _view * _proj;              var techDesc = _tech.Description;             for (int p = 0; p < techDesc.PassCount; p++)             {                 _fxWVP.SetMatrix(_boxWorld * viewProj);                 _tech.GetPassByIndex(p).Apply(ImmediateContext);                 ImmediateContext.DrawIndexed(_spaceShipIndexCount, _spaceShipIndexOffset, _spaceShipVertexOffset);              }             SwapChain.Present(0, PresentFlags.None);         }         protected override void OnMouseDown(object sender, MouseEventArgs mouseEventArgs)         {             _lastMousePos = mouseEventArgs.Location;             Window.Capture = true;         }         protected override void OnMouseUp(object sender, MouseEventArgs e)         {             Window.Capture = false;         }         protected override void OnMouseMove(object sender, MouseEventArgs e)         {             if (e.Button == MouseButtons.Left)             {                 var dx = MathF.ToRadians(0.25f * (e.X - _lastMousePos.X));                 var dy = MathF.ToRadians(0.25f * (e.Y - _lastMousePos.Y));                  _theta += dx;                 _phi += dy;                  _phi = MathF.Clamp(_phi, 0.1f, MathF.PI - 0.1f);             }             else if (e.Button == MouseButtons.Right)             {                 var dx = 0.01f * (e.X - _lastMousePos.X);                 var dy = 0.01f * (e.Y - _lastMousePos.Y);                 _radius += dx - dy;                  _radius = MathF.Clamp(_radius, 3.0f, 200.0f);             }             _lastMousePos = e.Location;         }          private void BuildGeometryBuffers()         {             var spaceShip = PolygonizeSpaceship(_spaceshipToShow);                           _spaceShipVertexOffset = 0;             _spaceShipIndexCount = spaceShip.Indices.Count;             _spaceShipIndexOffset = 0;              var totalVertexCount = spaceShip.Vertices.Count;             var totalIndexCount = _spaceShipIndexCount;              var vs = new List<VertexPC>();             foreach (var vertex in spaceShip.Vertices)             {                 vs.Add(new VertexPC(vertex.Position, Color.Black));             }              var vbd = new BufferDescription(VertexPC.Stride * totalVertexCount,                 ResourceUsage.Immutable, BindFlags.VertexBuffer,                 CpuAccessFlags.None, ResourceOptionFlags.None, 0);             _vb = new Buffer(Device, new DataStream(vs.ToArray(), false, false), vbd);              var indices = new List<int>();             indices.AddRange(spaceShip.Indices);               var ibd = new BufferDescription(sizeof(int) * totalIndexCount, ResourceUsage.Immutable,                 BindFlags.IndexBuffer, CpuAccessFlags.None, ResourceOptionFlags.None, 0);             _ib = new Buffer(Device, new DataStream(indices.ToArray(), false, false), ibd);          }



        public static MeshData PolygonizeSpaceship(Hull spaceshipHull)
        {
            var ret = new MeshData();
            var polygonalModel = new RoomPolygonizer(spaceshipHull.Rooms[0]).GetMeshes();

            ret.Vertices.AddRange(polygonalModel.Vertexes.Distinct().Select(a => 
            new GeometryGenerator.Vertex(
                (float)a.Position.X, (float)a.Position.Y, (float)a.Position.Z,
                0,0,0,
                0,0,0,
                0,0
                )));

            ret.Indices.AddRange(polygonalModel.Indexes);

            return ret;
        }                private void BuildFX()         {             ShaderBytecode compiledShader = null;             try             {                 compiledShader = new ShaderBytecode(new DataStream(File.ReadAllBytes("fx/color.fxo"), false, false));                 _fx = new Effect(Device, compiledShader);             }             catch (Exception ex)             {                 MessageBox.Show(ex.Message);                 return;             }             finally             {                 Util.ReleaseCom(ref compiledShader);             }              _tech = _fx.GetTechniqueByName("ColorTech");             _fxWVP = _fx.GetVariableByName("gWorldViewProj").AsMatrix();         }         private void BuildVertexLayout()         {             var vertexDesc = new[] {                 new InputElement("POSITION", 0, Format.R32G32B32_Float,                     0, 0, InputClassification.PerVertexData, 0),                 new InputElement("COLOR", 0, Format.R32G32B32A32_Float,                     12, 0, InputClassification.PerVertexData, 0)             };             Debug.Assert(_tech != null);             var passDesc = _tech.GetPassByIndex(0).Description;             _inputLayout = new InputLayout(Device, passDesc.Signature, vertexDesc);         }      } }       